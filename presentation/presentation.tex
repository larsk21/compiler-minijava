%% Beispiel-Präsentation mit LaTeX Beamer im KIT-Design
%% entsprechend den Gestaltungsrichtlinien vom 1. August 2020
%%
%% Siehe https://sdqweb.ipd.kit.edu/wiki/Dokumentvorlagen

\documentclass[navbaroff,en]{sdqbeamer} 

\usepackage{comment}
\usepackage{tikz}
\usepackage{listings}
% \usepackage[demo]{graphicx}
\usepackage{subfigure}
 
%% Titelbild
\titleimage{banner_2020_kit}

%% Gruppenlogo
\grouplogo{}

%% Gruppenname
\groupname{IPD - Programming Paradigms Group}

% Beginn der Präsentation

\title{Compiler Presentation - Group 3}
\subtitle{Compiler Lab WS21/22}
\author[Nikolai, Pascal, Lars, Niklas]{Nikolai Maas, Pascal Mehnert, Lars König, Niklas Betten}

\date[10.\,2.\,2022]{10. February 2022}

\lstset{
    language=Java,
    basicstyle=\small\ttfamily,
    tabsize=4,
    columns=fixed,
    showstringspaces=false,
    showtabs=false,
    keepspaces,
    commentstyle=\color{red},
    keywordstyle=\color{blue}
}

\begin{document}

%Titelseite
\KITtitleframe

\begin{frame}
	\frametitle{Compiler Overview}

	\centering \includegraphics[scale=0.5]{images/phases.ipe.pdf}

\end{frame}


\section{Front End}

\begin{frame}
	\frametitle{Parser}

	\begin{itemize}
		\item \textbf{Input:} Tokens generated by Lexer
		\item Recursive descent pull parser
		\item Based on SLL(3) grammar
		\item Precedence climber for expressions
		\item No anchors $\,\longrightarrow\,$ No error recovery

		\vspace{1em}

		\item \textbf{Output:} Abstract Syntax Tree
		\item Major node types realized with inheritance
		\item Enums used to distinguish node sub-types
	\end{itemize}

\end{frame}

\begin{frame}
	\frametitle{Semantic Analysis}

	\begin{contentblock}{Namespace Gathering}
		\begin{itemize}
			\item Collect class, field, and method declarations
			\item Ensure existence of unique \texttt{main}-method
		\end{itemize}
	\end{contentblock}


	\begin{contentblock}{Name and Type Analysis}
		\begin{itemize}
			\item Find and link variable declarations
			\item Calculate expression result types
			\item Resolve function call references
		\end{itemize}
	\end{contentblock}


	\begin{contentblock}{Semantic Checks}
		\begin{itemize}
			\item Ensure existence of \texttt{return} statement on every path
			\item Ensure \texttt{args} and \texttt{String} are never used
			\item \dots and other miscellaneous checks
		\end{itemize}
	\end{contentblock}

\end{frame}

\begin{frame}
	\frametitle{Transformation}

	\begin{itemize}
		\item \textbf{Input:} Attributed AST
		\item Generate and cache Firm types
		\item Implemented using visitors on the AST

		\vspace{1em}

		\item Special handling for \textit{Div} and \textit{Mod}
		\begin{itemize}
			\item 32-bit division with explicit overflow checks
			\item \textit{(64-bit division several times slower)}
		\end{itemize}

		\vspace{1em}

		\item \textbf{Output:} Single Firm graph for each function
	\end{itemize}

\end{frame}


\section{Middle End}


\begin{frame}
	\frametitle{Optimizations -- Overview}

	\begin{columns}
		\begin{column}{0.48\textwidth}
			\begin{itemize}
				\item Constant Propagation
				\item Arithmetic Identities
				\item Trivial Jumps \& Linear Blocks
				\item Arithmetic Strength Reduction
				\item Pure Functions
				\item Inliner
				\item Loop Invariant Code Motion
				\item Loop Unrolling
				\item Common Subexpression Elimination

				\vspace{1em}

				\item Unused Arguments
			\end{itemize}
		\end{column}
		\begin{column}{0.48\textwidth}
			\lstinputlisting{firm/fibonacci/Fib.short.java}

			\begin{figure}
				\begin{minipage}{.3\textwidth}
					\centering
					\includegraphics[scale=0.7]{images/arrow.ipe.pdf}
				\end{minipage}%
				\begin{minipage}{.6\textwidth}
					\centering
					\scalebox{0.115}{\input{firm/fibonacci/fibonacci.tikz}}
				\end{minipage}
			\end{figure}
		\end{column}
	\end{columns}

\end{frame}


\begin{frame}
    \frametitle{Optimizations -- Fixed Point Iterations}

	\begin{contentblock}{Call Graph}
		\begin{itemize}
			\item Used to walk functions in bottom-up order
			\item Passed to optimizations ($\rightarrow$ Inliner)
			\item Detect and prune dead functions
		\end{itemize}
	\end{contentblock}

	\begin{contentblock}{Local Optimizations}
		\begin{itemize}
			\item Applied to a single function
			\item Run all optimizations until FP is reached
		\end{itemize}
	\end{contentblock}

	\begin{contentblock}{Global Optimizations}
		\begin{itemize}
			\item Run on the entire program
			\item Return the set of changed functions
		\end{itemize}
	\end{contentblock}

\end{frame}

\begin{frame}
    \frametitle{Loop Unrolling}

	\begin{columns}
		\begin{column}{0.48\textwidth}
			\begin{itemize}
				\item[1.] Find closed natural loops
				\item[2.] Find loop variables
				\item[3.] Determine loop boundaries
				\item[4.] Calculate number of iterations
			\end{itemize}
		\end{column}
		\begin{column}{0.25\textwidth}
			\centering
			\scalebox{0.2}{%
				\input{firm/loop-unrolling/loop-unrolling-raw.tikz}
			}
		\end{column}
		\begin{column}{0.09\textwidth}
					\centering
					\includegraphics[scale=0.7]{images/arrow.ipe.pdf}
		\end{column}
		\begin{column}{0.16\textwidth}
			\centering
			\scalebox{0.13}{%
				\input{firm/loop-unrolling/loop-unrolling-opt.tikz}
			}
		\end{column}
	\end{columns}
\end{frame}






\section{Backend}

\begin{frame}
	\frametitle{Instruction Selection}
	\begin{columns}
		\begin{column}{0.55\textwidth}
			\begin{itemize}
				\item Uses simplified bottom-up pattern matching
				\item Does not resolve $\phi$-Instructions
			\end{itemize}

			\vspace{1em}

			\begin{contentblock}{Phase 1: Match Nodes}
				\begin{itemize}
					\item Match each node against (multiple) patterns
					\item Accept first matching pattern (no cost function)
				\end{itemize}
			\end{contentblock}

			\begin{contentblock}{Phase 2: Collect Instructions}
				\begin{itemize}
					\item Walk matches in topological order
					\item Ignore unnecessary predecessors
					\item Discard memory dependencies ($\rightarrow$ no reordering)
				\end{itemize}
			\end{contentblock}
		\end{column}
		\begin{column}{0.44\textwidth}
		 	\centering \includegraphics[scale=0.4]{images/pattern.ipe.pdf}
		\end{column}
	\end{columns}

\end{frame}

\begin{frame}
    \frametitle{Register Allocation - Techniques}

    \begin{itemize}
    	\item Blockwise
        \item Linear Scan
        \item Graph Coloring
    \end{itemize}

\end{frame}

\begin{frame}
\frametitle{Register Allocator - Overview}

\centering \includegraphics[scale=0.7]{images/overview.pdf}

\end{frame}

\begin{frame}
\frametitle{Register Allocator - Block Layout}

	\begin{columns}
		\begin{column}{0.65\textwidth}
			\begin{itemize}
				\item \textbf{Input:} unordered blocks (intermediate language)
				\item Calculate reverse postfix order
				\item Additionally: loop analysis
					\begin{itemize}
						\item Mapping between blocks and loops
						\item Try to find consecutive block layout for each loop\\ (minimizes lifetime of registers within loop)
					\end{itemize}
				\item \textbf{Output:} linear block ordering, annotated with loop depth
			\end{itemize}
		\end{column}
	
		 \begin{column}{0.35\textwidth}
		 	\centering \includegraphics[scale=0.7]{images/block_layout.pdf}
		 \end{column}
	\end{columns}
\end{frame}

\begin{frame}
\frametitle{Register Allocator - Lifetime Analysis}

\begin{columns}
	\begin{column}{0.65\textwidth}
		\begin{itemize}
			\item \textbf{Input:} linearized blocks
			\item Calculate lifetime intervals for each virtual register 
			\begin{itemize}
				\item Definition and last usage
				\item Differentiate input and output (allows reusing registers)
				\item Beware loops: lifetime extension required!
			\end{itemize}
			\item Collect other useful stats for each virtual register
			\begin{itemize}
				\item Loop depth
				\item \texttt{div}, \texttt{mod} and \texttt{call}
			\end{itemize}
			\item \textbf{Output:} register lifetimes and additional stats
		\end{itemize}
	\end{column}
	
	\begin{column}{0.35\textwidth}
		\centering \includegraphics[scale=0.7]{images/lifetimes.pdf}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Register Allocator - Register Assignment}

\begin{columns}
	\begin{column}{0.65\textwidth}
		\begin{itemize}
			\item \textbf{Input:} linearized blocks and lifetimes
			\item Assign virtual registers to hardware register or stack slot
			\item Linear scan over blocks, select best assignment greedily
			\item Spill decision based on loop depth and lifetime 
			\begin{itemize}
				\item Always spill for entire lifetime
			\end{itemize}
			\item Considerations when assigning a register:
			\begin{itemize}
				\item Reuse input register if possible
				\item Reduce and/or eliminate moves
				\item Callee-saved register in case of interfering calls
				\item According register for function arguments and return value
			\end{itemize}
			\item \textbf{Output:} register assignment
		\end{itemize}
	\end{column}
	
	\begin{column}{0.35\textwidth}
		\centering \includegraphics[scale=0.7]{images/allocation.pdf}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Register Allocator - Code Generation}

\begin{columns}
	\begin{column}{0.65\textwidth}
		\begin{itemize}
			\item \textbf{Input:} everything from above
			\item Verify assignment and generate the actual assembly
			\begin{itemize}
				\item Replace virtual registers
				\item Allocate temporary registers where needed
				\item Generate moves, spills and calling code
			\end{itemize}
			\item Function prolog and epilog (needs register usage)
			\item \textbf{Output:} assembly
		\end{itemize}
	
		\vspace{10pt}
		\begin{itemize}
			\item Calling convention: \texttt{x86-64} System V
			\begin{itemize}
				\item First six arguments in registers
				\item Efficient implementation via register permutation
			\end{itemize}
		\end{itemize}
	\end{column}
	
	\begin{column}{0.35\textwidth}
		\centering \includegraphics[scale=0.7]{images/code_generation.pdf}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
    \frametitle{Peephole Optimizations}

    \begin{itemize}
        \item fixed-size (per optimization) window of instructions
        \vspace{1em}
        \item Jump Inversion
    \end{itemize}

\end{frame}

\begin{frame}
    \frametitle{Assembly Output}

    \begin{itemize}
        \item ELF file format
        \item function prologs / epilogs
        \item link runtime library (written in C)
        \item passed to gcc
    \end{itemize}

\end{frame}

\begin{frame}
	\frametitle{Statistics}

	\begin{itemize}
		\item Duration: 16 weeks
		\item Pull requests: 143
		\item LOC: 15'093
		\begin{itemize}
			\item Frontend: 3'812
			\item Middle-End: 5'380
			\item Backend: 5'039
		\end{itemize}
	\end{itemize}

	% graph w/ commits over time

\end{frame}


\begin{frame}
\end{frame}

\appendix
\beginbackup

\backupend

\end{document}
