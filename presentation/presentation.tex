%% Beispiel-Präsentation mit LaTeX Beamer im KIT-Design
%% entsprechend den Gestaltungsrichtlinien vom 1. August 2020
%%
%% Siehe https://sdqweb.ipd.kit.edu/wiki/Dokumentvorlagen

\documentclass[navbaroff,en]{sdqbeamer} 

\usepackage{comment}
\usepackage{tikz}
\usepackage{listings}
% \usepackage[demo]{graphicx}
\usepackage{subfigure}
 
%% Titelbild
\titleimage{banner_2020_kit}

%% Gruppenlogo
\grouplogo{}

%% Gruppenname
\groupname{IPD - Programming Paradigms Group}

% Beginn der Präsentation

\title{Compiler Presentation - Group 3}
\subtitle{Compiler Lab WS21/22}
\author[Nikolai, Pascal, Lars, Niklas]{Nikolai Maas, Pascal Mehnert, Lars König, Niklas Betten}

\date[10.\,2.\,2022]{10. February 2022}

\lstset{
	language=Java,
	basicstyle=\small\ttfamily,
	tabsize=4,
	columns=fixed,
	showstringspaces=false,
	showtabs=false,
	keepspaces,
	commentstyle=\color{red},
	keywordstyle=\bfseries\color{kit-blue}
}

\begin{document}

%Titelseite
\KITtitleframe

\begin{frame}
	\frametitle{Compiler Overview}

	\centering \includegraphics[scale=0.5]{images/phases.ipe.pdf}

\end{frame}


\section{Front End}

\begin{frame}
	\frametitle{Parser}

	\begin{columns}
		\begin{column}{0.45\textwidth}
			\begin{itemize}
				\item \textbf{Input:} Tokens generated by Lexer
				\item Recursive descent pull parser
				\item Based on SLL(3) grammar
				\item Precedence climber for expressions
				\item No anchors $\,\longrightarrow\,$ No error recovery

				\vspace{1em}

				\item \textbf{Output:} Abstract Syntax Tree
				\item Major node types realized with inheritance
				\item Enums used to distinguish node sub-types
			\end{itemize}
		\end{column}

		\begin{column}{0.54\textwidth}
			\centering \includegraphics[scale=0.24]{images/ast_example.pdf}
		\end{column}
	\end{columns}

\end{frame}

\begin{frame}
	\frametitle{Semantic Analysis}
	\begin{columns}
		\begin{column}{0.52\textwidth}

	\begin{contentblock}{Namespace Gathering}
		\begin{itemize}
			\item Collect class, field, and method declarations
			\item Ensure existence of unique \texttt{main}-method
		\end{itemize}
	\end{contentblock}


	\begin{contentblock}{Name and Type Analysis}
		\begin{itemize}
			\item Find and link variable declarations
			\item Compute and check expression types
			\item Resolve function call references
		\end{itemize}
	\end{contentblock}


	\begin{contentblock}{Semantic Checks}
		\begin{itemize}
			\item Ensure existence of \texttt{return} statement on every path
			\item Ensure \texttt{\textbf{args}} and \texttt{\textbf{String}} are never used
			\item \dots and other miscellaneous checks
		\end{itemize}
	\end{contentblock}

\end{column}

\begin{column}{0.47\textwidth}
		\centering \includegraphics[scale=0.24]{images/semantic_tests.pdf}
\end{column}
\end{columns}

\end{frame}

\begin{frame}
	\frametitle{Transformation}

	\begin{columns}
		\begin{column}{0.45\textwidth}
			\begin{itemize}
				\item \textbf{Input:} Attributed AST
				\item Generate and cache Firm types
				\item Implemented using visitors on the AST

				\vspace{1em}

				\item Special handling for \textit{Div} and \textit{Mod}
				\begin{itemize}
					\item 32-bit division with explicit overflow checks
					\item \textit{(64-bit division several times slower)}
				\end{itemize}

				\vspace{1em}

				\item \textbf{Output:} Single Firm graph for each function
			\end{itemize}
		\end{column}
		\begin{column}{0.58\textwidth}
			\centering
			\scalebox{0.2}{\input{firm/transformation/transformation.tikz}}
		\end{column}
	\end{columns}

\end{frame}


\section{Middle End}


\begin{frame}
	\frametitle{Optimizations -- Overview}

	\begin{columns}
		\begin{column}{0.48\textwidth}
			\begin{itemize}
				\item Constant Propagation
				\item Arithmetic Identities
				\item Trivial Jumps \& Linear Blocks
				\item Arithmetic Strength Reduction
				\item Pure Functions
				\item Inliner
				\item Loop Invariant Code Motion
				\item Loop Unrolling
				\item Common Subexpression Elimination

				\vspace{1em}

				\item Unused Arguments
			\end{itemize}
		\end{column}
		\begin{column}{0.48\textwidth}
			\lstinputlisting{firm/fibonacci/Fib.short.java}

			\begin{figure}
				\begin{minipage}{.3\textwidth}
					\centering
					\includegraphics[scale=0.7]{images/arrow.ipe.pdf}
				\end{minipage}%
				\begin{minipage}{.6\textwidth}
					\centering
					\scalebox{0.115}{\input{firm/fibonacci/fibonacci.tikz}}
				\end{minipage}
			\end{figure}
		\end{column}
	\end{columns}

\end{frame}


\begin{frame}
	\frametitle{Optimizations -- Fixed Point Iteration}

	\begin{columns}
		\begin{column}{0.48\textwidth}
			\begin{contentblock}{Call Graph}
				\begin{itemize}
					\item Used to walk functions in bottom-up order
					\item Passed to optimizations ($\rightarrow$ needed for Inliner)
					\item Detect and prune dead functions
				\end{itemize}
			\end{contentblock}

			\begin{contentblock}{Local Optimizations}
				\begin{itemize}
					\item Applied to a single function
					\item Run all optimizations until FP is reached
				\end{itemize}
			\end{contentblock}

			\begin{contentblock}{Global Optimizations}
				\begin{itemize}
					\item Run on the entire program
					\item Return the set of changed functions
				\end{itemize}
			\end{contentblock}
		\end{column}
		\begin{column}{0.48\textwidth}
			\centering
			\includegraphics[scale=0.4]{images/call-graph.ipe.pdf}
		\end{column}
	\end{columns}

\end{frame}

\begin{comment}
\begin{frame}
	\frametitle{Optimizations -- Example}

	\begin{columns}
		\centering
		\begin{column}{0.2\textwidth}
			\centering
			\lstinputlisting[basicstyle=\normalsize\ttfamily]{firm/optimization/Example.min.java}
		\end{column}
		\begin{column}{0.05\textwidth}
			\centering
			\includegraphics[scale=0.7]{images/arrow.ipe.pdf}
		\end{column}
		\begin{column}{0.2\textwidth}
			\centering
			\scalebox{0.2}{\input{firm/optimization/initial.tikz}}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}
	\frametitle{Loop Unrolling}

	\begin{columns}
		\centering
		\begin{column}{0.4\textwidth}
			\begin{itemize}
				\item[1.] Find closed natural loops
				\item[2.] Find loop variables
				\item[3.] Determine loop boundaries
				\item[4.] Calculate number of iterations
				\vspace*{1em}
				\item[$\rightarrow$] Multiply and rewire the loop
			\end{itemize}
		\end{column}
		\begin{column}{0.2\textwidth}
			\centering
			\scalebox{0.2}{%
				\input{firm/optimization/initial.tikz}
			}
		\end{column}
		\begin{column}{0.05\textwidth}
			\centering
			\includegraphics[scale=0.7]{images/arrow.ipe.pdf}
		\end{column}
		\begin{column}{0.15\textwidth}
			\centering
			\scalebox{0.14}{\input{firm/optimization/after-unrolling.tikz}}
		\end{column}
	\end{columns}

\end{frame}

\begin{frame}
	\frametitle{Linear Blocks / Constant Propagation}

	\begin{columns}
		\centering
		\begin{column}{0.15\textwidth}
			\centering
			\scalebox{0.14}{\input{firm/optimization/after-unrolling.tikz}}
		\end{column}
		\begin{column}{0.05\textwidth}
			\centering
			\includegraphics[scale=0.7]{images/arrow.ipe.pdf}
		\end{column}
		\begin{column}{0.25\textwidth}
			\centering
			\scalebox{0.2}{\input{firm/optimization/after-linear-blocks.tikz}}
		\end{column}
		\begin{column}{0.05\textwidth}
			\centering
			\includegraphics[scale=0.7]{images/arrow.ipe.pdf}
		\end{column}
		\begin{column}{0.15\textwidth}
			\centering
			\scalebox{0.1}{\input{firm/optimization/after-constant.tikz}}
		\end{column}
	\end{columns}

\end{frame}
\end{comment}


\section{Backend}

\begin{frame}
	\frametitle{Instruction Selection}
	\begin{columns}
		\begin{column}{0.55\textwidth}
			\begin{itemize}
				\item Uses simplified bottom-up pattern matching
				\item Generates instructions in intermediate language
				\item Does not resolve $\phi$-Instructions ($\rightarrow$ separate phase)
			\end{itemize}

			\vspace{1em}

			\begin{contentblock}{Phase 1: Match Nodes}
				\begin{itemize}
					\item Match each node against (multiple) patterns
					\item Greedily accept matching pattern (no cost function)
				\end{itemize}
			\end{contentblock}

			\begin{contentblock}{Phase 2: Collect Instructions}
				\begin{itemize}
					\item Walk matches in topological order
					\item Ignore unnecessary predecessors
					\item Discard memory dependencies
					\begin{itemize}
						\item[$\rightarrow$] No instruction reordering implemented
					\end{itemize}
				\end{itemize}
			\end{contentblock}
		\end{column}
		\begin{column}{0.44\textwidth}
		 	\centering \includegraphics[scale=0.4]{images/pattern.ipe.pdf}
		\end{column}
	\end{columns}

\end{frame}

\begin{frame}
	\frametitle{Register Allocation - Techniques}

	\begin{columns}
		\begin{column}{0.65\textwidth}
			\begin{contentblock}{Blockwise Allocation}
				\begin{itemize}
					\item Load at beginning and spill at end of each block
					\item Use free-list to manage registers, greedy allocation
				\end{itemize}
			\end{contentblock}
	
			\begin{contentblock}{Linear Scan}
				\begin{itemize}
					\item Linear block ordering
					\item Scan through all blocks, greedy allocation
					\item Good results in practice
				\end{itemize}
			\end{contentblock}
	
			\begin{contentblock}{Graph Coloring}
				\begin{itemize}
					\item Construct register interference graph
					\item Coloring corresponds to register assignment
					\item Best results, but high complexity
				\end{itemize}
			\end{contentblock}
		\end{column}

		\begin{column}{0.35\textwidth}
			\vspace{40pt}
			\vfill
			\centering \includegraphics[scale=0.7]{images/techniques.pdf}
		\end{column}
	\end{columns}

\end{frame}

\begin{frame}[noframenumbering]
\frametitle{Register Allocation - Techniques}

\definecolor{darkgreen}{rgb}{0.15,0.8,0}
\setlength{\fboxsep}{2pt}

\begin{columns}
	\begin{column}{0.65\textwidth}
		\begin{contentblock}{Blockwise Allocation}
			\begin{itemize}
				\item Load at beginning and spill at end of each block
				\item Use free-list to manage registers, greedy allocation
			\end{itemize}
		\end{contentblock}
		
		\vspace{-2pt}
		\begin{contentblock}{\colorbox{darkgreen}{Linear Scan}}
			\begin{itemize}
				\item Linear block ordering
				\item Scan through all blocks, greedy allocation
				\item Good results in practice
			\end{itemize}
		\end{contentblock}
		
		\begin{contentblock}{Graph Coloring}
			\begin{itemize}
				\item Construct register interference graph
				\item Coloring corresponds to register assignment
				\item Best results, but high complexity
			\end{itemize}
		\end{contentblock}
	\end{column}
	
	\begin{column}{0.35\textwidth}
		\vspace{40pt}
		\vfill
		\centering \includegraphics[scale=0.7]{images/techniques.pdf}
	\end{column}
\end{columns}

\end{frame}

\begin{frame}
\frametitle{Register Allocator - Overview}

\centering \includegraphics[scale=0.7]{images/overview.pdf}

\end{frame}

\begin{frame}
\frametitle{Register Allocator - Block Layout}

	\begin{columns}
		\begin{column}{0.65\textwidth}
			\begin{itemize}
				\item \textbf{Input:} Unordered blocks (intermediate language)
				\item Calculate reverse postfix order for control flow
				\item Loop analysis
					\begin{itemize}
						\item Mapping between blocks and loops
						\item Try to find consecutive block layout for each loop\\ ($\rightarrow$ minimize lifetime of registers within loop)
					\end{itemize}
				\item \textbf{Output:} Linear block ordering, annotated with loop depth
			\end{itemize}
		\end{column}
	
		 \begin{column}{0.35\textwidth}
		 	\centering \includegraphics[scale=0.7]{images/block_layout.pdf}
		 \end{column}
	\end{columns}
\end{frame}

\begin{frame}
\frametitle{Register Allocator - Lifetime Analysis}

\begin{columns}
	\begin{column}{0.65\textwidth}
		\begin{itemize}
			\item \textbf{Input:} Linearized blocks
			\item Calculate lifetime intervals for each virtual register 
			\begin{itemize}
				\item Definition and last usage
				\item Differentiate input and output ($\rightarrow$ allows reusing registers)
				\item Beware loops: Lifetime extension required!
			\end{itemize}
			\item Collect other useful stats for each virtual register
			\begin{itemize}
				\item Loop depth
				\item \texttt{div}, \texttt{mod} and \texttt{call}
			\end{itemize}
			\item \textbf{Output:} Register lifetimes and additional stats
		\end{itemize}
	\end{column}
	
	\begin{column}{0.35\textwidth}
		\centering \includegraphics[scale=0.7]{images/lifetimes.pdf}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Register Allocator - Register Assignment}

\begin{columns}
	\begin{column}{0.7\textwidth}
		\begin{itemize}
			\item \textbf{Input:} Linearized blocks and lifetimes
			\item Assign virtual registers to hardware register or stack slot
			\item Linear scan over blocks, select best assignment greedily
			\item Spill decision based on loop depth and lifetime 
			\begin{itemize}
				\item Always spill for entire lifetime
			\end{itemize}
			\item Considerations when assigning a register:
			\begin{itemize}
				\item Reuse input register if possible
				\item Reduce and/or eliminate moves
				\item Callee-saved register in case of interfering calls
				\item Register used as function argument or return value
			\end{itemize}
			\item \textbf{Output:} Register assignment
		\end{itemize}
	\end{column}
	
	\begin{column}{0.3\textwidth}
		\centering \includegraphics[scale=0.7]{images/allocation.pdf}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Register Allocator - Code Generation}

\begin{columns}
	\begin{column}{0.7\textwidth}
		\begin{itemize}
			\item \textbf{Input:} Everything from above
			\item Verify assignment and generate the actual assembly
			\begin{itemize}
				\item Replace virtual registers
				\item Allocate temporary registers where needed
				\item Generate moves, spills and calling code
			\end{itemize}
			\item Function prolog and epilog (requires register usage)
			\item \textbf{Output:} \texttt{x86} Assembly
		\end{itemize}
	
		\vspace{10pt}
		\begin{itemize}
			\item Calling convention: \texttt{x86-64} System V
			\begin{itemize}
				\item First six arguments in registers
				\item Efficient implementation via register permutation
			\end{itemize}
		\end{itemize}
	\end{column}
	
	\begin{column}{0.3\textwidth}
		\centering \includegraphics[scale=0.7]{images/code_generation.pdf}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
	\frametitle{Statistics}

	\begin{columns}
		\begin{column}{0.3\textwidth}
			\begin{itemize}
				\item Duration: 17 weeks
				\item Pull requests: 143
				\item LOC: 15'093
				\begin{itemize}
					\item Frontend: 3'812
					\item Middle-End: 5'380
					\item Backend: 5'039
				\end{itemize}
			\end{itemize}
		\end{column}

		\begin{column}{0.7\textwidth}
			\centering \includegraphics[scale=0.43]{images/stats.pdf}
		\end{column}

	\end{columns}

	% graph w/ commits over time

\end{frame}


% \appendix
% \beginbackup

% \backupend

\end{document}
