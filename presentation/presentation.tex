%% Beispiel-Präsentation mit LaTeX Beamer im KIT-Design
%% entsprechend den Gestaltungsrichtlinien vom 1. August 2020
%%
%% Siehe https://sdqweb.ipd.kit.edu/wiki/Dokumentvorlagen

%% Beispiel-Präsentation

\documentclass[navbaroff,en]{sdqbeamer} 

\usepackage{comment}
\usepackage{tikz}
\usepackage{listings}
% \usepackage[demo]{graphicx}
\usepackage{subfigure}
 
%% Titelbild
\titleimage{banner_2020_kit}

%% Gruppenlogo
\grouplogo{}

%% Gruppenname
\groupname{IPD - Lehrstuhl Programmierparadigmen}

% Beginn der Präsentation

\title{Vorstellung Compiler - Gruppe 3}
\subtitle{Compilerpraktikum WS21/22}
\author[Nikolai, Pascal, Lars, Niklas]{Nikolai Maas, Pascal Mehnert, Lars König, Niklas Betten}

\date[10.\,2.\,2022]{10. Februar 2022}

\lstset{
    language=Java,
    basicstyle=\small\ttfamily,
    tabsize=4,
    columns=fixed,
    showstringspaces=false,
    showtabs=false,
    keepspaces,
    commentstyle=\color{red},
    keywordstyle=\color{blue}
}

\begin{document}

%Titelseite
\KITtitleframe

Inhaltsverzeichnis
\begin{frame}{Structure}
\tableofcontents
\end{frame}

\begin{frame}
	\frametitle{Compiler Overview}

	\centering \includegraphics[scale=0.5]{images/phases.ipe.pdf}

\end{frame}


\section{Front End}

\begin{frame}
	\frametitle{Parser}

	\begin{itemize}
		\item \textbf{Input:} Tokens generated by Lexer
		\item Recursive descent pull parser
		\item Based on SLL(3) grammar
		\item Precedence climber for expressions
		\item No anchors $\,\longrightarrow\,$ No error recovery

		\vspace{1em}

		\item \textbf{Output:} Abstract Syntax Tree
		\item Major node types realized with inheritance
		\item Enums used to distinguish node sub-types
	\end{itemize}

\end{frame}

\begin{frame}
	\frametitle{Semantic Analysis}

	\begin{contentblock}{Namespace Gathering}
		\begin{itemize}
			\item Collect class, field, and method declarations
			\item Ensure existence of unique \texttt{main}-method
		\end{itemize}
	\end{contentblock}


	\begin{contentblock}{Name and Type Analysis}
		\begin{itemize}
			\item Find and link variable declarations
			\item Calculate expression result types
			\item Resolve function call references
		\end{itemize}
	\end{contentblock}


	\begin{contentblock}{Semantic Checks}
		\begin{itemize}
			\item Ensure existence of \texttt{return} statement on every path
			\item Ensure \texttt{args} and \texttt{String} are never used
			\item \dots and other miscellaneous checks
		\end{itemize}
	\end{contentblock}

\end{frame}

\begin{frame}
	\frametitle{Transformation}

	\begin{itemize}
		\item \textbf{Input:} Attributed AST
		\item Generate and cache Firm types
		\item Implemented using visitors on the AST

		\vspace{1em}

		\item Special handling for \textit{Div} and \textit{Mod}
		\begin{itemize}
			\item 32-bit division with explicit overflow checks
			\item \textit{(64-bit division several times slower)}
		\end{itemize}

		\vspace{1em}

		\item \textbf{Output:} Single Firm graph for each function
	\end{itemize}

\end{frame}


\section{Middle End}


\begin{frame}
	\frametitle{Optimizations -- Overview}

	\begin{columns}
		\begin{column}{0.48\textwidth}
			\begin{itemize}
				\item Constant Propagation
				\item Arithmetic Identities
				\item Trivial Jumps \& Linear Blocks
				\item Arithmetic Strength Reduction
				\item Pure Functions
				\item Inliner
				\item Loop Invariant Code Motion
				\item Loop Unrolling
				\item Common Subexpression Elimination

				\vspace{1em}

				\item Unused Arguments
			\end{itemize}
		\end{column}
		\begin{column}{0.48\textwidth}
			\lstinputlisting{firm/fibonacci/Fib.short.java}

			\begin{figure}
				\begin{minipage}{.3\textwidth}
					\centering
					\includegraphics[scale=0.7]{images/arrow.ipe.pdf}
				\end{minipage}%
				\begin{minipage}{.6\textwidth}
					\centering
					\scalebox{0.115}{\input{firm/fibonacci/fibonacci.tikz}}
				\end{minipage}
			\end{figure}
		\end{column}
	\end{columns}

\end{frame}


\begin{frame}
    \frametitle{Optimizations -- Fixed Point Iterations}

	\begin{contentblock}{Call Graph}
		\begin{itemize}
			\item Used to walk functions in bottom-up order
			\item Passed to optimizations ($\rightarrow$ Inliner)
			\item Detect and prune dead functions
		\end{itemize}
	\end{contentblock}

	\begin{contentblock}{Local Optimizations}
		\begin{itemize}
			\item Applied to a single function
			\item Run all optimizations until FP is reached
		\end{itemize}
	\end{contentblock}

	\begin{contentblock}{Global Optimizations}
		\begin{itemize}
			\item Run on the entire program
			\item Return the set of changed functions
		\end{itemize}
	\end{contentblock}

\end{frame}

\begin{frame}
    \frametitle{Trivial Jumps \& Linear Blocks}

	\Huge need a meaningful example here

\end{frame}


% \begin{frame}
% 	\frametitle{Pure Functions}

% 	\begin{itemize}
% 		\item pure -> kein Schreibzugriff auf Speicher
% 		\item const -> auf kein Lesezugriff auf Speicher (no mem)
% 		\item Termination (Rekursion, Schleife)
% 		\item returns newly allocated memory
% 		\item remove unused pure functions (incl. alloc)
% 	\end{itemize}

% \end{frame}

% \begin{frame}
%     \frametitle{Inliner}

%     \begin{itemize}
%         \item constant arguments
%         \item inside loop -> high prio
%         \item code size change (factor [global] + abs [per func])
%     \end{itemize}

% \end{frame}

% \begin{frame}
%     \frametitle{Loop Invariant Code Motion}

%     \begin{itemize}
%         \item flat loops
%         \item move to loop entry point dominator
%         \item unconditional execution of moved nodes
%         \item minimize reg pressure für cheap nodes
%         \begin{itemize}
%             \item delta loop in edges
%             \item move distance
%             \item number of invariant successors
%         \end{itemize}
%     \end{itemize}

% \end{frame}

\begin{frame}
    \frametitle{Loop Unrolling}

	\begin{columns}
		\begin{column}{0.48\textwidth}
			\begin{itemize}
				\item[1.] Find closed natural loops
				\item[2.] Find loop variables
				\item[3.] Determine loop boundaries
				\item[4.] Calculate number of iterations
			\end{itemize}
		\end{column}
		\begin{column}{0.25\textwidth}
			\centering
			\scalebox{0.2}{%
				\input{firm/loop-unrolling/loop-unrolling-raw.tikz}
			}
		\end{column}
		\begin{column}{0.09\textwidth}
					\centering
					\includegraphics[scale=0.7]{images/arrow.ipe.pdf}
		\end{column}
		\begin{column}{0.16\textwidth}
			\centering
			\scalebox{0.13}{%
				\input{firm/loop-unrolling/loop-unrolling-opt.tikz}
			}
		\end{column}
	\end{columns}
\end{frame}






\section{Backend}

% \begin{frame}
%     \frametitle{Intermediate Language}

%     \begin{itemize}
%         \item close to x86-64 assembler
%         \item virtual registers
%         \item phis can be assigned to basic blocks -> resolved later
%         \item additional virtual instructions (div / mod / call)
%     \end{itemize}

% \end{frame}

\begin{frame}
	\frametitle{Instruction Selection}
	\begin{columns}
		\begin{column}{0.55\textwidth}
			\begin{itemize}
				\item Uses simplified bottom-up pattern matching
				\item Does not resolve $\phi$-Instructions
			\end{itemize}

			\vspace{1em}

			\begin{contentblock}{Phase 1: Match Nodes}
				\begin{itemize}
					\item Match each node against (multiple) patterns
					\item Accept first matching pattern (no cost function)
					\item Matches reference required predecessors
				\end{itemize}
			\end{contentblock}

			\begin{contentblock}{Phase 2: Collect Instructions}
				\begin{itemize}
					\item Walk matches in topological order
					\item Ignore unnecessary predecessors
					\item Discard memory dependencies ($\rightarrow$ no reordering)
				\end{itemize}
			\end{contentblock}
		\end{column}
		\begin{column}{0.44\textwidth}
		 	\centering \includegraphics[scale=0.4]{images/pattern.ipe.pdf}
		\end{column}
	\end{columns}


    % \begin{itemize}
    %     \item bottom-up pattern matching -> single pattern per node
    %     \item no cost function
    %     \item bottom-up pattern collection (postorder on matched patterns -> ignores unnecessary predecessor patterns)
    %     \item topological order of instructions
    %     \item virtual registers
    %     \item basic and advanced patterns (add: add r r, addi r, add r i, lea)
    %     \item register restrictions not considered
    %     \item separate phi resolving phase

    %     \item no separate instruction scheduling
    % \end{itemize}

\end{frame}

\begin{frame}
    \frametitle{Phi Resolving}

    \begin{itemize}
        \item works on intermediate language
        \item add moves to predecessor blocks
        \item ?
        \item permutations
        \item critical edges
    \end{itemize}

\end{frame}

\begin{frame}
    \frametitle{Register Allocation - Techniques}

    \begin{itemize}
    	\item Blockwise
        \item Linear Scan
        \item Graph Coloring
    \end{itemize}

\end{frame}

\begin{frame}
\frametitle{Register Allocator - Overview}

\centering \includegraphics[scale=0.7]{images/overview.pdf}

\end{frame}

\begin{frame}
\frametitle{Register Allocator - Block Layout}

	\begin{columns}
		\begin{column}{0.65\textwidth}
			\begin{itemize}
				\item \textbf{Input:} unordered blocks (intermediate language)
				\item Calculate reverse postfix order
				\item Additionally: loop analysis
					\begin{itemize}
						\item Mapping between blocks and loops
						\item Try to find consecutive block layout for each loop\\ (minimizes lifetime of registers within loop)
					\end{itemize}
				\item \textbf{Output:} linear block ordering, annotated with loop depth
			\end{itemize}
		\end{column}
	
		 \begin{column}{0.35\textwidth}
		 	\centering \includegraphics[scale=0.7]{images/block_layout.pdf}
		 \end{column}
	\end{columns}
\end{frame}

\begin{frame}
\frametitle{Register Allocator - Lifetime Analysis}

\begin{columns}
	\begin{column}{0.65\textwidth}
		\begin{itemize}
			\item \textbf{Input:} linearized blocks
			\item Calculate lifetime intervals for each virtual register 
			\begin{itemize}
				\item Definition and last usage
				\item Differentiate input and output (allows reusing registers)
				\item Beware loops: lifetime extension required!
			\end{itemize}
			\item Collect other useful stats for each virtual register
			\begin{itemize}
				\item Loop depth
				\item \texttt{div}, \texttt{mod} and \texttt{call}
			\end{itemize}
			\item \textbf{Output:} register lifetimes and additional stats
		\end{itemize}
	\end{column}
	
	\begin{column}{0.35\textwidth}
		\centering \includegraphics[scale=0.7]{images/lifetimes.pdf}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Register Allocator - Register Assignment}

\begin{columns}
	\begin{column}{0.65\textwidth}
		\begin{itemize}
			\item \textbf{Input:} linearized blocks and lifetimes
			\item Assign virtual registers to hardware register or stack slot
			\item Linear scan over blocks, select best assignment greedily
			\item Spill decision based on loop depth and lifetime 
			\begin{itemize}
				\item Always spill for entire lifetime
			\end{itemize}
			\item Considerations when assigning a register:
			\begin{itemize}
				\item Reuse input register if possible
				\item Reduce and/or eliminate moves
				\item Callee-saved register in case of interfering calls
				\item According register for function arguments and return value
			\end{itemize}
			\item \textbf{Output:} register assignment
		\end{itemize}
	\end{column}
	
	\begin{column}{0.35\textwidth}
		\centering \includegraphics[scale=0.7]{images/allocation.pdf}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Register Allocator - Code Generation}

\begin{columns}
	\begin{column}{0.65\textwidth}
		\begin{itemize}
			\item \textbf{Input:} everything from above
			\item Verify assignment and generate the actual assembly
			\begin{itemize}
				\item Replace virtual registers
				\item Allocate temporary registers where needed
				\item Generate moves, spills and calling code
			\end{itemize}
			\item Function prolog and epilog (needs register usage)
			\item \textbf{Output:} assembly
		\end{itemize}
	
		\vspace{10pt}
		\begin{itemize}
			\item Calling convention: \texttt{x86-64} System V
			\begin{itemize}
				\item First six arguments in registers
				\item Efficient implementation via register permutation
			\end{itemize}
		\end{itemize}
	\end{column}
	
	\begin{column}{0.35\textwidth}
		\centering \includegraphics[scale=0.7]{images/code_generation.pdf}
	\end{column}
\end{columns}
\end{frame}

\begin{frame}
    \frametitle{Register Allocator}

    \begin{itemize}
        \item[1.] block order
        \begin{itemize}
            \item topological (reverse postorder, control flow)
            \item loop aware (loop blocks directly after loop header)
        \end{itemize}
        \item[2.] lifetime analysis
        \begin{itemize}
            \item linear through blocks
            \item lifetime for all virtual registers
            \item expand lifetime of variables in loops
            \item reuse register if virtual register lifetime ends as instruction argument
            \item linear lifetimes (no splits)
            \item collect additional information for register allocation heuristic (number of calls / divs, loop depth)
        \end{itemize}
    \end{itemize}

\end{frame}

\begin{frame}
    \frametitle{Register Allocator}

    \begin{itemize}
        \item[3.] register allocation
        \begin{itemize}
            \item linear scan
            \item generates mapping from virtual to processor? registers
            \item heuristic for spill decision (loop depth)
            \item spill virtual register for entire lifetime
            \item unify virtual registers / registers
            \begin{itemize}
                \item in-out virtual registers
                \item registers for call arguments (in / out)
            \end{itemize}
            \item reuse stack slots if lifetime don't overlap
        \end{itemize}
        \item[4.] code generation
        \begin{itemize}
            \item x86-64 call convetion (systemv)
            \begin{itemize}
                \item 6 arguments in register
                \item rest on stack
                \item caller / callee stacked registers
                \item efficient implementation by calculating register permutation
            \end{itemize}
            \item 16-bit alignment for stdlib calls only
            \item omit load of spilled register if temp. register is still available (inside basic blocks)
        \end{itemize}
    \end{itemize}

\end{frame}

\begin{frame}
    \frametitle{Peephole Optimizations}

    \begin{itemize}
        \item fixed-size (per optimization) window of instructions
        \vspace{1em}
        \item Jump Inversion
    \end{itemize}

\end{frame}

\begin{frame}
    \frametitle{Assembly Output}

    \begin{itemize}
        \item ELF file format
        \item function prologs / epilogs
        \item link runtime library (written in C)
        \item passed to gcc
    \end{itemize}

\end{frame}


\begin{frame}
\end{frame}

\appendix
\beginbackup

\backupend

\end{document}
